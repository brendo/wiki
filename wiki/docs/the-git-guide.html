<h1>The Git Guide</h1>
<h2>Common tasks</h2>
<h3>Creating a repository</h3>

Repositories are no longer to be created on dev, instead please login to Codebase to create a new repository:

<ol>
    <li>Check to see if the client has a Project, if it doesn't then create a new Project for the client.</li>
    <li>Create a new repository inside of the clients project for the website you're working on.</li>
</ol>

<h3>Creating a working copy</h3>

<ol>
    <li>Copy the repository URL from codebase</li>
    <li>Change into your <tt>~/Sites</tt> folder</li>
    <li>And run the following command: <tt>git clone <i>url</i></tt></li>
</ol>

<h3>Remove a submodule</h3>

So adding a submodule is easy, removing one is a pain in the arse

<ol>
    <li>Delete the relevant line from the <tt>.gitmodules</tt> file.</li>
    <li>Delete the relevant section from <tt>.git/config</tt>.</li>
    <li>Run <tt>git rm --cached <i>path-to-submodule</i></tt> (no trailing slash).</li>
    <li>Commit and delete the now untracked submodule files.</li>
</ol>

<h2>Tips and tricks</h2>

You should definitely read the <a href="http://book.git-scm.com/">Git Book</a>, but at least read the <a href="http://book.git-scm.com/5_customizing_git.html">Customizing Git</a> page.

<h3>Sharing manifest configuration</h3>

First off, rename the <tt>manifest</tt> folder to <tt>manifest.dev</tt>, then inside of the cache, logs and tmp folders create a single <tt>.gitignore</tt> file that contains:

<pre>*
!.gitignore</pre>

This will tell git to ignore the contents of those directories, except for the <tt>.gitignore</tt> file itself, it also has the useful side affect of automatically creating the cache, logs and tmp folders when you clone a repository.

Now, edit the <tt>.gitignore</tt> file in the root of the repository and make sure it contains manifest (but not <tt>manifest.dev</tt>).

Once that's done, git add your <tt>manifest.dev</tt> folder to the repository and create a symlink so Symphony can find the <tt>manifest</tt>:

<pre>git add manifest.dev
ln -s manifest.dev manifest</pre>

Now whenever you make a configuration change, you can share it by simply committing and pushing - and you don't have to worry about your development <tt>manifest</tt> causing trouble on the live server.

As an extra, you could also apply this to live deployments, so you can test and edit the live manifest offline, just create yourself a <tt>manifest.live</tt>.

<h3>Saving uncommitted changes</h3>

Git allows you to save uncommitted changes, this can be useful in a number of situations:

<ol>
    <li>You where updating a site, but need to revert back to the stable code temporarily to fix a bug</li>
    <li>You where making changes to the wrong branch, or want to move your changes to a new branch</li>
</ol>

To save your changes simply run:

<pre>git stash save <i>message</i></pre>

This saves your stash with a message to remind you what it was for, to list saved stashes run:

<pre>git stash list</pre>

To restore the last stash change simply run:

<pre>git stash pop</pre>

For more detailed help, run:

See <tt>git help stash</tt> and the <a href="http://book.git-scm.com/4_stashing.html">Git Book</a> for more information.

<h3>Custom log formats</h3>

You can customize your <tt>git log</tt> format, for example, I use the following command to display the log in a compressed two line format:

<pre>git log --format="%Cred%h %Cgreenby %an %ar%n%Creset%s%n"</pre>

It looks something like this, but with colours:

<pre>aa7eb5f by Someone 25 hours ago
The commit messages</pre>

If you come up with a format you want to use every time you run <tt>git log</tt>, you can configure git to use your format:

<pre>git config --global format.pretty "%Cred%h %Cgreenby %an %ar%n%Creset%s%n"</pre>

See <tt>git help log</tt> and the <a href="http://book.git-scm.com/3_reviewing_history_-_git_log.html">Git Book</a> for more information.